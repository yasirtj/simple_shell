#include "shell_header.h"

/**
 * read_user_input - reads user input and returns the allocated string
 * @user_input_size: pointer to the size of the input
 * Return: allocated user input string
 */
char *read_user_input(size_t *user_input_size);

int main(void)
{
	char *user_input = NULL;
	size_t user_input_size;

	for (;;)
	{
		if (isatty(STDIN_FILENO))
		{
			view_prompt();
			write(1, "$ ", 2);
		}
		else
		{
			view_prompt();
		}

		user_input = read_user_input(&user_input_size);
		if (user_input == NULL)
		{
			custom_exit(1, "Failed to read user input or allocate memory!\n");
		}

		char **cmd = tokenize_cmd(user_input, delimeter);

		free(user_input);
	}

	return (0);
}

char *read_user_input(size_t *user_input_size)
{
	char *user_input = NULL, *string_copy = NULL, *generated_token, *delimeter = " \n";
	char **new_tokens;
	ssize_t read_char_num;
	size_t number_of_tokens = 0, i = 0;

	read_char_num = getline(&user_input, user_input_size, stdin);
	if (read_char_num == -1)
	{
		custom_exit(1, "Shell Exited!\n");
	}

	string_copy = malloc(sizeof(char) * (read_char_num + 1));
	if (string_copy == NULL || user_input == NULL)
	{
		custom_free(string_copy);
		custom_free(user_input);
		return (NULL);
	}
	else
	{
		strcpy(string_copy, user_input);
	}

	generated_token = strtok(user_input, delimeter);
	while (generated_token != NULL)
	{
		number_of_tokens++;
		generated_token = strtok(NULL, delimeter);
	}

	number_of_tokens++;
	new_tokens = malloc(sizeof(char *) * (number_of_tokens + 1));
	if (new_tokens == NULL)
	{
		custom_exit(1, "Failed to allocate memory for tokens!\n");
	}

	generated_token = strtok(string_copy, delimeter);
	while (generated_token != NULL)
	{
		new_tokens[i] = malloc(sizeof(char) * (strlen(generated_token) + 1));
		if (new_tokens[i] != NULL && generated_token != NULL)
		{
			strcpy(new_tokens[i], generated_token);
		}
		new_tokens[i][strlen(generated_token)] = '\0';
		generated_token = strtok(NULL, delimeter);
		i++;
	}

	new_tokens[i] = NULL;
	free(string_copy);
	execute_command(new_tokens);

	for (i = 0; new_tokens[i] != NULL; i++)
	{
		free(new_tokens[i]);
	}

	free(new_tokens);

	return (user_input);
}

